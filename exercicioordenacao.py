# -*- coding: utf-8 -*-
"""ExercicioOrdenacao.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1URMBwXW2Ye4SYLjNB-6BhnScOffd2OwW

# Bubble - O(N²)
"""

def bolha(lis):
    copia = lis.copy()
    copia.sort()
    for p in range(1, len(lis)):
        
        for i in range(len(lis)-p):
            if lis[i] > lis[i+1]:
                lis[i], lis[i+1] = lis[i+1], lis[i] 
        if lis == copia:
            return lis

"""# Bubble Sort Otimizado

"""

def bubble(lista):
    
  for i in range(len(lista)):
        
    # Registra se trocou
    troca = False
    
    for j in range(0, len(lista) - i - 1):

      # Compara dois elementos
      if lista[j] > lista[j + 1]:

        # troca acontece se os elementos não estão na ordem certa
        temp = lista[j]
        lista[j] = lista[j+1]
        lista[j+1] = temp

        troca = True
          
    # Se não trocou é porque a lista já está ordenada
    if not troca:
      break

"""# Selection sort - O(N²)"""

def selection(lis):
  for p in range(len(lis)-1):
    ime=p # armazena em ime o indice do menor elemento
    for i in range (p+1, len(lis)): # Percorrer o vetor para encontrar o menor
      if lis[i] < lis[ime]:
        ime = i
    lis[p],lis[ime] = lis[ime],lis[p]
  print('Selection sort: ',lis)

"""# Quick Sort - O(N²)"""

def quick(lista):
    
    if len(lista) <= 1:
        return lista  # Se o tamanho da lista for menor ou igual a 1 então retorna a lista (pois está vazia ou com apenas 1 elemento)
    else:
        v = lista.pop() # Último valor é retirado da lista para ser comparado

    maiores = []
    menores = []

    for i in lista:
        if i >v:
            maiores.append(i)

        else:
            menores.append(i)

    return quick(menores) + [v] + quick(maiores) # Faz a junção da lista de valores menores que V e os maiores, colocando V no meio

"""# Merge Sort - O(N log n)"""

def merge(lista):
    if len(lista) > 1:
        meio = len(lista) // 2
        esquerda = lista[:meio]
        direita = lista[meio:]
        # Chamada rescursiva esquerda e direita
        merge(esquerda)
        merge(direita)
        # Variáveis para mover direita e esquerda
        e = 0
        d = 0
        
        # Variável de resultado (Lista Ordenada)
        lo = 0
        
        while e < len(esquerda) and d < len(direita):
            if esquerda[e] <= direita[d]:
              # Se o valor for menor então ele é colocado na lista ordenada
              lista[lo] = esquerda[e]
              # Move a variável esquerda para frente
              e += 1
            else:
                lista[lo] = direita[d]
                d += 1
            # Move a váriável para frente
            lo += 1
        # Para os valores remanescentes 
        while e < len(esquerda):
            lista[lo] = esquerda[e]
            e += 1
            lo += 1
        while d < len(direita):
            lista[lo]=direita[d]
            d += 1
            lo += 1

"""# Programa principal"""

# Geração da lista aleatória
from time import time
from random import randint
MAXVAL = 10000
lista = [randint(1, MAXVAL) for _ in range(MAXVAL)]

copia = lista.copy()
t = time()
bubble(copia)
print('Bubble sort: ',copia) # Bubble sort
dt = time() - t
print(f'Tempo Bubble sort = {dt:.5f}s\n')


copia = lista.copy()
t = time()
print('Quick Sort: ',quick(copia))
dt = time() - t
print(f'Tempo Quick Sort = {dt:.5f}s\n')

copia = lista.copy()
t = time()
selection(copia) # Selection sort
dt = time() - t
print(f'Tempo Selection sort = {dt:.5f}s\n')


copia = lista.copy()
t = time()
merge(copia)
print('Merge sort: ',copia) # Merge sort
dt = time() - t
print(f'Tempo Merge sort = {dt:.5f}s\n')


copia = lista.copy()
to = time()
copia.sort() # Tim sort
print(f'Tim sort',copia)
dto = time() - to
print(f'Tempo Tim sort = {dto:.5f}s')

#... para todos os métodos de ordenação